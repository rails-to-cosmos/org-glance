#+TITLE: org-glance
#+AUTHOR: Dmitry Akatov
#+EMAIL: akatovda@yandex.com
#+CATEGORY: org-glance
#+PROPERTY: REPO_ALL Dev Test Prod
#+TAGS: License Documentation
#+TAGS: Experiment Test
#+PROPERTY: header-args:emacs-lisp :tangle (oldt-tt '("Test" "org-glance-tests.el") '("Experiment" "no") '(t "yes")) :results silent :noweb yes
#+PROPERTY: header-args:markdown :tangle (oldt-tt '("Documentation" "README.md") '(t "no"))
#+PROPERTY: header-args:org :tangle no

* Hello
** README                                                                      :Documentation:
#+begin_src markdown
Org-glance: walk in the woods with pleasure
===============================

Fast, clean and convenient way of traversing your org-mode forest.

Turn org-mode into context-aware bookmark storage, password manager,
flexible build system or whatever you can imagine with ease.

## Running tests

### Batch mode

    emacs -batch -l ert -l org-glance-tests.el -f ert-run-tests-batch-and-exit

### Org-mode

Browse link `Setup development environment`. After that you can build
project using `C-x y m` key or running `org-glance-devtools/build`
command from `org-glance.org` buffer.
#+end_src
** License                                                                     :License:
#+begin_src emacs-lisp
;;; org-glance.el --- org-mode traversing. Fast and convenient.

;; Copyright (C) 2018-2019 Dmitry Akatov

;; Author: Dmitry Akatov <akatovda@yandex.com>
;; Created: 29 September, 2018
;; Version: 0.1

;; Keywords: org-mode tools
;; Homepage: https://github.com/rails-to-cosmos/org-glance

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This package allows you to manage bookmarks and travel around the
;; digital world with an org-mode power behind your shoulders.

;;; Code:
#+end_src
** Requirements
#+begin_src emacs-lisp
(require 'org)
(require 'cl-lib)
(require 'subr-x)
(require 'seq)
#+end_src
* Customs
#+begin_src emacs-lisp
(defgroup org-glance nil
  "\nOptions concerning glancing entries."
  :tag "Org Glance"
  :group 'org)

(defcustom org-glance-cache-file
  (concat user-emacs-directory "org-glance--org-glance-cache.org")
  "A file to store headlines visited."
  :group 'org-glance
  :type 'string)

(condition-case nil
    (make-directory (file-name-directory org-glance-cache-file))
  (error nil))

(defvar org-glance-defaults--separator " â†’ ")
#+end_src
* Utils
** buffer-mode
#+begin_src emacs-lisp
(defun buffer-mode (&optional buffer-or-name)
  "Returns the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (buffer-local-value 'major-mode
   (if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+end_src
** headline-tags
#+begin_src emacs-lisp
(defun org-glance-headline-contains-tags-p (&rest tags)
  (equal (seq-intersection tags (org-get-tags)) tags))
#+end_src
* Testing                                                                       :Test:
** requirements
#+begin_src emacs-lisp
(require 'ert)
(load-file "org-glance.el") ;; for batch-mode
(require 'org-glance)
#+end_src
** utils
*** trim-string
#+begin_src emacs-lisp
(defun trim-string (string)
  "Remove white spaces in beginning and ending of STRING.
White space here is any of: space, tab, emacs newline (line feed, ASCII 10)."
  (replace-regexp-in-string "\\`[ \t\n]*" "" (replace-regexp-in-string "[ \t\n]*\\'" "" string)))
#+end_src
*** with-temp-org-buffer
#+begin_src emacs-lisp
(defmacro with-temp-org-buffer (s &rest forms)
  "Create a temporary org-mode buffer with contents S and execute FORMS."
  `(save-excursion
     (with-temp-buffer
       (org-mode)
       (goto-char 0)
       (insert ,s)
       (goto-char 0)
       ,@forms)))

(defmacro org-glance--with-temp-filebuffer (&rest body)
  "Open temp-file with org-glance prefix into a temporary buffer
execute BODY there like `progn', then kill the buffer and delete
the file returning the result of evaluating BODY."
  `(save-window-excursion
     (let ((fn (make-temp-file "org-glance-")))
       (find-file fn)
       (unwind-protect
           ,@body
         (save-buffer)
         (kill-buffer)
         (delete-file fn)))))
#+end_src
*** test-links
#+begin_src emacs-lisp
(defun org-glance-test (&rest args)
  (save-excursion
    (with-temp-buffer
      (org-mode)
      (let* ((context (plist-get args :context))
             (input (plist-get args :input))
             (action (plist-get context :action))
             (expected (plist-get context :expected))
             (begin-marker (with-current-buffer (messages-buffer)
                             (point-max-marker)))
             (expression (format "(+ %i %i)" (random 10) (random 10)))
             (buffer (current-buffer))
             (org-confirm-elisp-link-function nil)
             (unread-command-events
              (listify-key-sequence
               (kbd (format "%s RET" input)))))
        (insert (format "* [[elisp:%s][%s]]" (org-link-escape expression) input))
        (apply 'org-glance context)
        (cond (action (= (funcall action) expected))
              (t (string= (format "%s => %s" expression (eval (read expression)))
                          (thread-first
                              (with-current-buffer (messages-buffer)
                                (buffer-substring begin-marker (point-max-marker)))
                            s-lines butlast -last-item trim-string))))))))
#+end_src
* Classes                                                                       :Experiment:
** og-scope

#+begin_src emacs-lisp
(defclass og-scope ()
  ((source :type (or string buffer)
           :initarg :source)

   ;; private declarations
   (name :type string
         :initarg :name)

   (type :type symbol
         :initarg :type)

   (headlines :type list
              :initarg :headlines)

   (state :type (or string nil)
          :initarg :state))
  "Unified interface for buffer/file scopes.")

(cl-defmethod initialize-instance :after ((scope og-scope) &rest args)
  ;; determine scope type
  (let ((source (oref scope :source)))

    ;; Possible beautify and optimization: switch to opened buffer instead of finding file
    ;; (live-buffers (remove nil (mapcar 'buffer-file-name (buffer-list))))

    ;; determine scope type
    (oset scope :type
          (cond ((and (stringp source) (file-exists-p source))
                 'file)

                ((and (bufferp source) (buffer-file-name source) (file-exists-p (buffer-file-name source)))
                 'file-buffer)

                ((bufferp source)
                 'buffer)))

    ;; determine scope name
    (oset scope :name
          (case (oref scope :type)
            ('buffer
             (buffer-name source))

            ('file
             (expand-file-name source))

            ('file-buffer
             (expand-file-name (buffer-file-name source)))))

    ;; determine scope state and contents
    (case (oref scope :type)
      ('buffer
       (with-current-buffer source
         (oset scope :state (buffer-hash))
         (oset scope :headlines (org-element-parse-buffer 'headline))))

      ('file
       (with-temp-buffer
         (insert-file-contents source)
         (oset scope :state (buffer-hash))
         (oset scope :headlines (org-element-parse-buffer 'headline))))

      ('file-buffer
       (with-temp-buffer
         (insert-file-contents (buffer-file-name source))
         (oset scope :state (buffer-hash))
         (oset scope :headlines (org-element-parse-buffer 'headline)))))))

;; (let ((headlines (oref scope headlines)))
;;   (org-element-map headlines 'headline
;;     (lambda (headline)
;;       headline
;;       ;; (org-element-property "ITEM" headline)
;;       ))

;;   ;; (cl-loop for (title level) in entries
;;   ;;          for i below (length entries)
;;   ;;          with prev-level
;;   ;;          initially (progn
;;   ;;                      (goto-char (point-max))
;;   ;;                      (org-insert-heading nil nil t)
;;   ;;                      (insert scope)
;;   ;;                      (org-set-property "CREATED" (current-time-string))
;;   ;;                      (org-set-property "STATE" state)
;;   ;;                      (org-insert-heading-respect-content)
;;   ;;                      (org-do-demote))
;;   ;;          do (progn
;;   ;;               (insert title)
;;   ;;               (when prev-level
;;   ;;                 (cond ((> prev-level level) (dotimes (ld (- prev-level level)) (org-do-promote)))
;;   ;;                       ((< prev-level level) (dotimes (ld (- level prev-level)) (org-do-demote))))))

;;   ;;          when (< (+ i 1) (length entries))
;;   ;;          do (progn
;;   ;;               (org-insert-heading-respect-content)
;;   ;;               (setq prev-level level)))
;;   )
#+end_src

** og-cache

#+begin_src emacs-lisp
(defclass og-cache ()
  ((scopes :type hash-table
           :initform (cl-make-hash-table :test #'equal)
           :initarg :scopes)))

(cl-defmethod og-cache--add-scope ((cache og-cache) scope)
  "Insert SCOPE into CACHE if scope state has been modified then return t.
If state has not been modified, do not update CACHE and return nil."
  (with-slots (name state) scope
    (let* ((scopes (oref cache :scopes))
           (ex-scope (gethash name scopes)))
      (if ex-scope
          (unless (equal state (oref ex-scope :state))
            (puthash name scope scopes)
            t)
        (puthash name scope scopes)
        t))))

(ert-deftest og-cache-test/scoping ()
  (let ((scope (og-scope :source (current-buffer)))
        (cache (og-cache)))
    (og-cache--add-scope cache scope)))

(ert-run-tests-batch 'og-cache-test/scoping)
#+end_src

* Features
** org-glance
#+begin_src emacs-lisp
(defun org-glance (&rest args)
  "Use optional ARGS to customize your glancing blows:
- SCOPE :: org-file or SCOPE from org-map-entries (org.el)
- PROMPT :: completing read title (default: \"Glance: \")
- SEPARATOR :: completing read entry separator (default: \" â†’ \")
- FILTER :: list or one filter of type lambda/symbol/string to specify entries in completing read.

  Possible default filters:
  - links :: keep entries with link in title
  - encrypted :: keep entries with :crypt: tag

  You can customize default filters by setting org-glance--default-filters variable.

- ACTION
  - if specified, call it with point on selected entry
  - if entry has an org-link in title, browse it
- OUTLINE-IGNORE :: list of strings to ignore in outline-path

- INPLACE :: do not build scope file if specified

\(fn [:scope SCOPE] [:prompt PROMPT] [:separator SEPARATOR] [:filter FILTER] [:action ACTION])"
  (let* ((user-scopes (or (plist-get args :scope)          nil))
         (aggregated-scopes (org-glance--aggregate-scopes user-scopes))
         (err-nothing-found (or (plist-get args :nothing-found-msg) "Nothing to glance for"))

         (user-filter (or (plist-get args :filter)       (lambda () t)))

         (save-outline-visibility-p (plist-get args :save-outline-visibility))
         (no-cache-file-p           (plist-get args :no-cache-file))
         (org-glance-cache-file (if no-cache-file-p
                                    (make-temp-file "org-glance-")
                                  org-glance-cache-file))

         (outline-settings (record 'org-glance-settings--outline
                                   :scope (or aggregated-scopes (list (current-buffer)))
                                   :separator (or (plist-get args :separator) org-glance-defaults--separator)
                                   :outline-ignore (plist-get args :outline-ignore)
                                   :inplace t ;; (plist-get args :inplace)
                                   ;; temporary while outplace completions fail
                                   :filters (org-glance--filter-predicates user-filter)))

         (prompt    (or (plist-get args :prompt)         "Glance: "))
         (action    (or (plist-get args :action)         nil))

         (entries (or (org-glance--entries outline-settings)
                      (error "%s %s"
                             err-nothing-found
                             (prin1-to-string aggregated-scopes))))
         (result (org-glance--compl-visit prompt entries action save-outline-visibility-p)))
    (when no-cache-file-p
      (when-let ((fb (get-file-buffer org-glance-cache-file)))
        (kill-buffer fb))
      (delete-file org-glance-cache-file))
    result))
#+end_src
** outliner
#+begin_src emacs-lisp
(defun org-glance--get-entry-coordinates (&rest args)
  "Return outline path of current `'org-mode`' entry.

Org node titles separated by SEPARATOR, titles specified in
OUTLINE-IGNORE will be ignored.

All FILTERS lambdas must be t."
  (let* ((separator           (or (plist-get args :separator)           org-glance-defaults--separator))
         (outline-ignore      (or (plist-get args :outline-ignore)      nil))
         (filters             (or (plist-get args :filters)             nil))
         (inplace-p           (or (plist-get args :inplace)             nil))
         (scope               (or (plist-get args :scope)               nil))
         (item (org-entry-get (point) "ITEM"))
         (path (funcall (if inplace-p 'append 'cdr) (org-get-outline-path t)))
         (outline (cl-set-difference path outline-ignore :test 'string=))
         (coordinates (mapconcat 'identity (cl-list* ;; (org-glance-scope--get-name scope)
                                                     outline) separator)))
    (when (and (cl-every 'funcall filters)
               (not (thread-first coordinates s-trim string-empty-p)))
      (list coordinates (point-marker)))))
#+end_src
** visitor
*** impl
#+begin_src emacs-lisp
(defun org-glance-scope--visitor (settings scope)
  (save-window-excursion
    (let* ((scope               (aref settings 2))
           (separator           (aref settings 4))
           (outline-ignore      (aref settings 6))
           (inplace-p           (aref settings 8))
           (filters             (aref settings 10)))
      (org-glance-cache--read-contents scope)
      (org-map-entries (apply-partially
                        'org-glance--get-entry-coordinates
                        :separator separator
                        :outline-ignore outline-ignore
                        :filters filters
                        :inplace inplace-p
                        :scope scope)))))
#+end_src
*** visit-entry-at-point
#+begin_src emacs-lisp
(defun org-glance--visit-entry-at-point (&optional action)
  (save-excursion
    (if action
        (funcall action)
      (let* ((line (thing-at-point 'line t))
             (search (string-match org-any-link-re line))
             (link (substring line (match-beginning 0) (match-end 0))))
        (org-open-link-from-string link)))))
#+end_src
*** compl-visit
#+name: compl-visit
#+begin_src emacs-lisp
(defun org-glance--compl-visit (prompt entries action &optional save-outline-visibility-p)
  "PROMPT org-completing-read on ENTRIES and call ACTION on selected.
If there are no entries, raise exception."
  (when (seq-empty-p entries)
    (error "Empty set"))

  (let* ((choice (org-completing-read prompt entries))
         (marker (cadr (assoc-string choice entries)))
         (org-link-frame-setup (cl-acons 'file 'find-file org-link-frame-setup)))
    (with-current-buffer (marker-buffer marker)
      (org-goto-marker-or-bmk marker)
      (org-glance--visit-entry-at-point action))))
#+end_src
*** Tests [4/4]
**** DONE Can visit empty cache file                                         :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/can-work-with-empty-cache-file ()
  "Should work with empty cache file."
  (should
   (org-glance-test
    :context '(:no-cache-file t)
    :input "Hello")))
#+end_src
**** DONE Can visit org-links                                                :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/can-handle-org-links ()
  "Test that we can handle org-links."
  (should
   (org-glance-test
    :context '(:no-cache-file t)
    :input "elisp-link")))
#+end_src
**** DONE Can complete non-file buffers                                      :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/compl-non-file-buffer ()
  "Should work properly from non-file buffers."
  (should
   (org-glance-test
    :context '(:no-cache-file t
               :inplace t
               :scope (list buffer))
    :input "elisp-link")))
#+end_src
**** DONE Can call custom action on entry                                    :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/call-custom-action ()
  "Should call custom action if specified."
  (should
   (org-glance-test
    :context '(:action (lambda () 1)
               :expected 1
               :inplace t
               :scope (list buffer))
    :input "elisp-link")))
#+end_src
** entries
#+begin_src emacs-lisp
(defun org-glance--entries (settings)
  "Return glance entries by SCOPE.

Specify SEPARATOR and OUTLINE-IGNORE to customize
outline-paths appearence.

When INPLACE flag specified, do not modify *org-glance-scope* buffer.

Add some FILTERS to filter unwanted entries."
  (let* ((scope               (aref settings 2))
         (separator           (aref settings 4))
         (outline-ignore      (aref settings 6))
         (inplace-p           (aref settings 8))
         (filters             (aref settings 10))

         ;; Possible beautify and optimization: switch to opened buffer instead of finding file
         ;; (live-buffers (remove nil (mapcar 'buffer-file-name (buffer-list))))

         (handler (apply-partially (if inplace-p
                                       #'org-glance-scope--visitor
                                     #'org-glance-scope--implant)
                                   settings)))

    ;; (-keep (mapcar 'org-glance-scope--get-type scope))
    (loop for fob in scope
          append (let* ((scope-type (org-glance-scope--get-type fob))
                        (entries (funcall handler fob)))
                   (remove nil entries)))))
#+end_src
** scoping
*** implant
#+begin_src emacs-lisp
(defun org-glance-scope--implant (scope)
  (with-temp-file org-glance-cache-file
    (org-mode)

    (when (file-exists-p org-glance-cache-file)
      (insert-file-contents org-glance-cache-file))

    (let* ((contents (org-glance-cache--get-scope-state-headlines scope))
           (state (car contents))
           (entries (cadr contents))
           (scope-name (org-glance-scope--get-name scope))
           (cached-scope (org-glance-cache--get-scope scope-name)))

      (when (and (or (not cached-scope)
                     (not (string= state (car cached-scope))))
                 (> (length entries) 0)
                 (not (string= org-glance-cache-file scope-name)))
        (org-glance-cache--remove-scope scope-name)
        (org-glance-cache--add-scope scope-name entries state)
        ;; TODO: possible optimization/add-scope can return scope
        (setq cached-scope (org-glance-cache--get-scope scope-name)))

      (when-let ((scope-point (cadr cached-scope)))
        (let ((outliner (apply-partially
                         'org-glance--get-entry-coordinates
                         :separator separator
                         :outline-ignore outline-ignore
                         :filters filters
                         :inplace inplace-p
                         :scope org-glance-cache-file)))
          (save-excursion
            (goto-char scope-point)
            (org-map-entries outliner nil 'tree)))))))
#+end_src
*** type-getter
#+begin_src emacs-lisp
(defun org-glance-scope--get-type (scope)
  (cond ((and (stringp scope) (file-exists-p scope)) 'file)
        ((and (bufferp scope) (buffer-file-name scope) (file-exists-p (buffer-file-name scope))) 'file-buffer)
        ((bufferp scope) 'buffer)))
#+end_src
*** name-getter
#+begin_src emacs-lisp
(defun org-glance-scope--get-name (scope)
  (s-trim
   (case (org-glance-scope--get-type scope)
     ('file (expand-file-name scope))
     ('file-buffer (expand-file-name (buffer-file-name scope)))
     ('buffer (buffer-name scope)))))
#+end_src
*** defaults
**** archives
#+begin_src emacs-lisp
(defun org-glance-scope--list-archives ()
  (let ((fn (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
    (directory-files-recursively default-directory (concat fn ".org_archive"))))
#+end_src
*** aggregator
#+begin_src emacs-lisp
(defvar org-glance--default-scopes-alist
  `((file-with-archives . (lambda () (org-glance-scope--list-archives)))))

(alist-get 'org-file-archives org-glance--default-scopes-alist)

(defun org-glance--aggregate-scopes (&optional scopes)
  "Provides list of scopes (scope may be buffer or existing file).
Without specifying SCOPES it returns list with current buffer."

  (let* ((scopes (cond ((or (stringp scopes)
                            (and (symbolp scopes) (not (null scopes))))
                        (list scopes))
                       (t scopes)))

         (ascopes (cl-loop for scope in scopes

                           ;; collect buffers
                           when (bufferp scope) collect scope
                           when (and (symbolp scope) (alist-get scope org-glance--default-scopes-alist))
                           collect (funcall (alist-get scope org-glance--default-scopes-alist))

                           ;; collect functions that return buffers or filenames
                           when (functionp scope)
                           collect (when-let ((fob (funcall scope)))
                                     (if (bufferp fob)
                                         fob
                                       (or (get-file-buffer (expand-file-name fob))
                                           (expand-file-name fob))))

                           ;; collect file names
                           when (and (stringp scope) (file-exists-p (expand-file-name scope)))
                           collect (or (get-file-buffer (expand-file-name scope))
                                       (expand-file-name scope)))))

    (or (remove 'nil (seq-uniq (-flatten ascopes)))
        (list (current-buffer)))))
#+end_src
*** Tests [2/4]
**** DONE Return must contain no duplicates                                  :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/scopes-contain-no-duplicates ()
  "Scope should not contain duplicates."
  (let ((scopes
         (org-glance--with-temp-filebuffer
          (org-glance--aggregate-scopes
           (list
            ;; buffer
            (current-buffer)

            ;; filename
            (buffer-file-name)

            ;; function that returns buffer
            'current-buffer

            ;; function that returns filename
            'buffer-file-name)))))
    (should (= (length scopes) 1))))
#+end_src
**** DONE Proper handling lambda with nil return                             :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/scopes-can-handle-nil-lambdas ()
  "Ignore nil lambdas in scopes."
  (should
   (not (null
         (condition-case nil
             (org-glance--aggregate-scopes (list (lambda () nil)))
           (error nil))))))
#+end_src
**** TODO Input must handle scopes of types: buffer, fun, filename
**** TODO Proper handle nil input
** filtering
*** defaults
#+begin_src emacs-lisp
(defvar org-glance--default-filters
  '((links . (lambda () (org-match-line (format "^.*%s.*$" org-bracket-link-regexp))))
    (encrypted . (lambda () (seq-intersection (list "crypt") (org-get-tags-at))))))
#+end_src
*** factorization
#+begin_src emacs-lisp
(defun org-glance--filter-predicates (filter)
  "Factorize FILTER into list of predicates. Acceptable FILTER values:
- list of symbols (possible default filters) and lambdas (custom filters)
- string name of default filter
- symbolic name of default filter
- lambda function with no params called on entry"
  (cond ((functionp filter) (list filter))
        ((symbolp filter) (list (alist-get filter org-glance--default-filters)))

        ((stringp filter) (org-glance--filter-predicates (intern filter)))
        ((listp filter) (mapcar #'(lambda (f) (thread-first f org-glance--filter-predicates car)) filter))
        (t (error "Unable to recognize filter."))))
#+end_src
*** Tests [3/3]
**** DONE Filter produces proper predicates                                  :Test:
#+begin_src emacs-lisp
(defun org-glance-req/filter-produces-proper-predicates-p (input expected)
  "Can we split user filter into atomic predicates?"
  (equal (org-glance--filter-predicates input) expected))

(defun org-glance-test-explainer/filter-produces-proper-predicates (filter expected)
  (cond ((functionp filter) "Unable to resolve lambda filter")
        ((symbolp filter) "Unable to resolve symbolic filter")
        ((stringp filter) "Unable to resolve string filter")
        ((listp filter) (loop for elt in filter
                              when (functionp elt) return "Unable to resolve lambda from filter list"
                              when (symbolp elt)   return "Unable to resolve symbol from filter list"
                              when (stringp elt)   return "Unable to resolve string from filter list"))
        (t "Unrecognized filter must raise an error")))

(put 'org-glance-req/filter-produces-proper-predicates-p
     'ert-explainer
     'org-glance-test-explainer/filter-produces-proper-predicates)

(ert-deftest org-glance-test/filter-produces-proper-predicates-lambda ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           (lambda () t) '((lambda () t)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-symbol ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           'links (list (alist-get 'links org-glance--default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-string ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           "links" (list (alist-get 'links org-glance--default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-list ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           (list 'links (lambda () t) "links")
           (list (alist-get 'links org-glance--default-filters)
                 (lambda () t)
                 (alist-get 'links org-glance--default-filters)))))
#+end_src
**** DONE Filter removes entries                                             :Test:

#+begin_src emacs-lisp
(ert-deftest org-glance-test/filter-removes-entries ()
  "Test filtering."
  (should
   (condition-case nil
        (org-glance-test
         :context (list :no-cache-file t
                        :inplace t
                        :filter (lambda () (org-match-line "^ example$")))
         :input "elisp-link")
     (error t))))
#+end_src

**** DONE Filter doesnt remove suitable entries                              :Test:

#+begin_src emacs-lisp
(ert-deftest org-glance-test/filter-doesnt-remove-suitable-entries ()
  (should
   (org-glance-test
    :context (list :no-cache-file t
                   :inplace t
                   :filter (lambda () (org-match-line "^.*elisp-link.*$")))
    :input "elisp-link")))
#+end_src

** TODO cache
*** add-scope
#+begin_src emacs-lisp
;; org-element-interpret-data

(defun org-glance-cache--add-scope (scope entries state)
  (cl-loop for (title level) in entries
           for i below (length entries)
           with prev-level
           initially (progn
                       (goto-char (point-max))
                       (org-insert-heading nil nil t)
                       (insert scope)
                       (org-set-property "CREATED" (current-time-string))
                       (org-set-property "STATE" state)
                       (org-insert-heading-respect-content)
                       (org-do-demote))
           do (progn
                (insert title)
                (when prev-level
                  (cond ((> prev-level level) (dotimes (ld (- prev-level level)) (org-do-promote)))
                        ((< prev-level level) (dotimes (ld (- level prev-level)) (org-do-demote))))))

           when (< (+ i 1) (length entries))
           do (progn
                (org-insert-heading-respect-content)
                (setq prev-level level))))
#+end_src
*** get-scope
#+begin_src emacs-lisp
(defun org-glance-cache--get-scope (scope-name)
  (car
   (org-element-map (org-element-parse-buffer 'headline) 'headline
     (lambda (hl)
       (let* (
              ;; maybe map properties?
              ;; (org-element-map hl 'node-property
              ;;   (lambda (np)
              ;;     (cons (org-element-property :key np)
              ;;           (org-element-property :value np))))

              (level (org-element-property :level hl))
              (title (org-element-property :title hl))
              (begin (org-element-property :begin hl))

              (end (org-element-property :end hl)))
         (when (and (= level 1) (string= title scope-name))
           (save-excursion
             (goto-char begin)
             (let* ((props (org-element--get-node-properties))
                    (state (plist-get props :STATE)))
               (org-set-property "USED" (current-time-string))
               (list state begin end)))))))))
#+end_src
*** get-scope-state-elements
#+begin_src emacs-lisp
(defun org-glance-cache--get-scope-state-headlines (scope)
  (with-temp-buffer
    (org-mode)
    (org-glance-cache--insert-contents scope)
    (list (buffer-hash)
          (org-element-parse-buffer 'headline))))
#+end_src
*** delete-scope
#+begin_src emacs-lisp
(defun org-glance-cache--remove-scope (scope-name)
  (when-let (scope (org-glance-cache--get-scope scope-name))
    (delete-region (cadr scope) (caddr scope))))
#+end_src
*** insert-contents
#+begin_src emacs-lisp
(defun org-glance-cache--insert-contents (scope)
  (case (org-glance-scope--get-type scope)
    ('file (insert-file-contents scope))
    ('file-buffer (insert-file-contents (buffer-file-name scope)))
    ('buffer (insert-buffer-substring-no-properties scope))))
#+end_src
*** read-contents
#+begin_src emacs-lisp
(defun org-glance-cache--read-contents (scope)
  (case (org-glance-scope--get-type scope)
    ('file (find-file scope))
    ('file-buffer (switch-to-buffer scope))
    ('buffer (switch-to-buffer scope))))
#+end_src
** TODO sort-entries                                                           :Experiment:
*** Tests
**** classification problem
classes:
- i.e. bookmarks or passwords
- items must be normally distributed
- hashtable of items?

independent variables (normalization needed):
- (sxhash (buffer-hash))
- (point)
- (sxhash (substring-no-properties (thing-at-point 'line)))
- (sxhash (buffer-file-name))
- (sxhash (save-window-excursion (org-clock-goto) (substring-no-properties (thing-at-point 'line))))
- org-clock tags, properties
- buffer major mode

connections:
-

#+begin_src emacs-lisp
;; (require 'eieio)

;; (cl-defmethod add-to-cache)
;; (cl-defmethod get-from-cache)
;; (cl-defmethod insert-contents ())

(oref (og-scope :source "/tmp/hello.txt") state)



(oref  state)

;; (defclass og-context (eieio-persistent)
;;   ((mode
;;     :type symbol
;;     :initarg :mode
;;     :initform (buffer-mode))

;;    (file
;;     :type string
;;     :initarg :file
;;     :initform "~/.context")

;;    (target
;;     :type string
;;     :initarg :target)

;;    (targets
;;     :type cl-hash-table
;;     :initform (make-hash-table :test 'equal)
;;     :allocation :class
;;     :documentation "Targets with features."))
;;   "Org-glance context.")

;; (cl-defmethod initialize-instance :after ((obj og-context) &rest _)
;;   (with-slots (mode target targets) obj
;;     (let* ((features (gethash target targets (make-hash-table :test 'equal)))
;;            (coeff (+ (gethash mode features 0) 1)))
;;       (puthash mode coeff features)
;;       (puthash target features targets))))

;; (require 'json)

;; ;; slots
;; (loop for slot in (eieio-class-slots og-context)
;;       collect (eieio-slot-descriptor-name slot))

;; ;; targets
;; (with-temp-file "~/.context"
;;   (insert (json-encode-hash-table (oref-default og-context targets))))

;; (json-read-file "~/.context")
#+end_src
** DONE provision
#+begin_src emacs-lisp
(provide 'org-glance)
;;; org-glance.el ends here
#+end_src
*** Tests [1/1]
**** DONE feature-provision                                                  :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/feature-provision ()
  (should (featurep 'org-glance)))
#+end_src
* Applications
** org-glance-snippets
** org-glance-passwords
** org-glance-bookmarks
** org-glance-fs
* Todo
** TODO Use org-current-tag-alist
** TODO cache properties
** TODO profiler-start/profiler-report analyze
** TODO Fix fast insertion error (org-glance-cache-file does not have time to create)
* Settings
# Local Variables:
# org-literate-test-buffer: "*org-glance-tests*"
# org-literate-test-selector: "^org-glance-test/"
# org-use-tag-inheritance: t
# org-source-preserve-indentation: t
# org-adapt-indentation: nil
# indent-tabs-mode: nil
# End:
