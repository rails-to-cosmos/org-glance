#+TITLE: org-glance
#+AUTHOR: Dmitry Akatov
#+EMAIL: akatovda@yandex.com
#+CATEGORY: org-glance
#+PROPERTY: REPO_ALL Dev Test Prod
#+TAGS: License Documentation
#+TAGS: Experiment Test
#+PROPERTY: header-args:emacs-lisp :tangle (oldt-tt '("Test" "org-glance-tests.el") '("Experiment" "no") '(t "yes")) :results silent :noweb yes
#+PROPERTY: header-args:markdown :tangle (oldt-tt '("Documentation" "README.md") '(t "no"))
#+PROPERTY: header-args:org :tangle no

* Hello
** README                                                                      :Documentation:
#+begin_src markdown
Org-glance: walk in the woods with pleasure
===============================

Fast, clean and convenient way of traversing your org-mode forest.

Turn org-mode into context-aware bookmark storage, password manager,
flexible build system or whatever you can imagine with ease.

## Running tests

### Batch mode

    emacs -batch -l ert -l org-glance-tests.el -f ert-run-tests-batch-and-exit

### Org-mode

Browse link `Setup development environment`. After that you can build
project using `C-x y m` key or running `org-glance-devtools/build`
command from `org-glance.org` buffer.
#+end_src
** License                                                                     :License:
#+begin_src emacs-lisp
;;; org-glance.el --- org-mode traversing. Fast and convenient.

;; Copyright (C) 2018-2019 Dmitry Akatov

;; Author: Dmitry Akatov <akatovda@yandex.com>
;; Created: 29 September, 2018
;; Version: 0.1

;; Keywords: org-mode tools
;; Homepage: https://github.com/rails-to-cosmos/org-glance

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; This package allows you to manage bookmarks and travel around the
;; digital world with an org-mode power behind your shoulders.

;;; Code:
#+end_src
** Requirements
#+begin_src emacs-lisp
(require 'org)
(require 'cl-lib)
(require 'subr-x)
(require 'seq)
#+end_src
* Customs
#+begin_src emacs-lisp
(defgroup org-glance nil
  "\nOptions concerning glancing entries."
  :tag "Org Glance"
  :group 'org)

(defcustom org-glance-cache-file
  (concat user-emacs-directory "org-glance--org-glance-cache.org")
  "A file to store headlines visited."
  :group 'org-glance
  :type 'string)

(condition-case nil
    (make-directory (file-name-directory org-glance-cache-file))
  (error nil))

(defvar org-glance-defaults--separator " → ")
#+end_src
* Utils
** buffer-mode
#+begin_src emacs-lisp
(defun buffer-mode (&optional buffer-or-name)
  "Returns the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (buffer-local-value 'major-mode
   (if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+end_src
** headline-tags
#+begin_src emacs-lisp
(defun org-glance-headline-contains-tags-p (&rest tags)
  (equal (seq-intersection tags (org-get-tags)) tags))
#+end_src
* Testing                                                                       :Test:
** requirements
#+begin_src emacs-lisp
(require 'ert)
(load-file "org-glance.el") ;; for batch-mode
(require 'org-glance)
#+end_src
** utils
*** trim-string
#+begin_src emacs-lisp
(defun trim-string (string)
  "Remove white spaces in beginning and ending of STRING.
White space here is any of: space, tab, emacs newline (line feed, ASCII 10)."
  (replace-regexp-in-string "\\`[ \t\n]*" "" (replace-regexp-in-string "[ \t\n]*\\'" "" string)))
#+end_src
*** with-temp-org-buffer
#+begin_src emacs-lisp
(defmacro with-temp-org-buffer (s &rest forms)
  "Create a temporary org-mode buffer with contents S and execute FORMS."
  `(save-excursion
     (with-temp-buffer
       (org-mode)
       (goto-char 0)
       (insert ,s)
       (goto-char 0)
       ,@forms)))

(defmacro org-glance--with-temp-filebuffer (&rest body)
  "Open temp-file with org-glance prefix into a temporary buffer
execute BODY there like `progn', then kill the buffer and delete
the file returning the result of evaluating BODY."
  `(save-window-excursion
     (let ((fn (make-temp-file "org-glance-")))
       (find-file fn)
       (unwind-protect
           ,@body
         (save-buffer)
         (kill-buffer)
         (delete-file fn)))))
#+end_src
*** test-links
#+begin_src emacs-lisp
(defun org-glance-test (&rest args)
  (save-excursion
    (with-temp-buffer
      (org-mode)
      (let* ((context (plist-get args :context))
             (input (plist-get args :input))
             (action (plist-get context :action))
             (expected (plist-get context :expected))
             (begin-marker (with-current-buffer (messages-buffer)
                             (point-max-marker)))
             (expression (format "(+ %i %i)" (random 10) (random 10)))
             (buffer (current-buffer))
             (org-confirm-elisp-link-function nil)
             (unread-command-events
              (listify-key-sequence
               (kbd (format "%s RET" input)))))
        (insert (format "* [[elisp:%s][%s]]" (org-link-escape expression) input))
        (apply 'org-glance context)
        (cond (action (= (funcall action) expected))
              (t (string= (format "%s => %s" expression (eval (read expression)))
                          (thread-first
                              (with-current-buffer (messages-buffer)
                                (buffer-substring begin-marker (point-max-marker)))
                            s-lines butlast -last-item trim-string))))))))
#+end_src
* Features
** org-glance
#+begin_src emacs-lisp
(defun org-glance (&rest args)
  "Use optional ARGS to customize your glancing blows:
- SCOPE :: org-file or SCOPE from org-map-entries (org.el)
- PROMPT :: completing read title (default: \"Glance: \")
- SEPARATOR :: completing read entry separator (default: \" → \")
- FILTER :: list or one filter of type lambda/symbol/string to specify entries in completing read.

  Possible default filters:
  - links :: keep entries with link in title
  - encrypted :: keep entries with :crypt: tag

  You can customize default filters by setting org-glance--default-filters variable.

- ACTION
  - if specified, call it with point on selected entry
  - if entry has an org-link in title, browse it
- OUTLINE-IGNORE :: list of strings to ignore in outline-path

- INPLACE :: do not build scope file if specified

\(fn [:scope SCOPE] [:prompt PROMPT] [:separator SEPARATOR] [:filter FILTER] [:action ACTION])"
  (let* ((scope (org-glance-scope-create (plist-get args :scope)))
         (filter (org-glance-filter-create (plist-get args :filter)))
         (action (plist-get args :action))

         (prompt (or (plist-get args :prompt) "Glance: "))
         (err-nothing-found (or (plist-get args :nothing-found-msg) "Nothing to glance for"))

         ;; (save-outline-visibility-p (plist-get args :save-outline-visibility))
         ;; (no-cache-file-p           (plist-get args :no-cache-file))
         ;; (org-glance-cache-file (if no-cache-file-p
         ;;                            (make-temp-file "org-glance-")
         ;;                          org-glance-cache-file))
         ;; (outline-settings (record 'org-glance-settings--outline
         ;;                           :scope scope
         ;;                           :separator (or (plist-get args :separator) org-glance-defaults--separator)
         ;;                           :outline-ignore (plist-get args :outline-ignore)
         ;;                           :inplace t ;; (plist-get args :inplace)
         ;;                           ;; temporary while outplace completions fail
         ;;                           :filters (org-glance--filter-predicates user-filter)))

         (entries (or (org-glance-scope-entries scope)
                      (error "%s %s"
                             err-nothing-found
                             (prin1-to-string scope))))
         (entry (-some->> entries
                          ;; (apply-partially #'org-glance-entries-filter filter)
                          org-glance-entries-browse)))
    (org-glance-entry-location-act entry action)
    ;; (when no-cache-file-p
    ;;   (when-let ((fb (get-file-buffer org-glance-cache-file)))
    ;;     (kill-buffer fb))
    ;;   (delete-file org-glance-cache-file))
    ;; result
    ))
#+end_src
** scope
*** def
#+begin_src emacs-lisp
(cl-defstruct (org-glance-scope (:constructor org-glance-scope--create)
                                (:copier nil))
  type name handle)

(defvar org-glance--default-scopes-alist
  `((file-with-archives . (lambda () (org-glance-scope--list-archives)))))

(defun org-glance-scope--prepr (scope)
  (cond ((bufferp scope) scope)
        ((and (symbolp scope) (alist-get scope org-glance--default-scopes-alist))
         (funcall (alist-get scope org-glance--default-scopes-alist)))
        ((functionp scope) (when-let ((fob (funcall scope)))
                             (if (bufferp fob)
                                 fob
                               (or (get-file-buffer (expand-file-name fob))
                                   (expand-file-name fob)))))
        ((and (stringp scope)
              (file-exists-p (expand-file-name scope))) (or (get-file-buffer (expand-file-name scope))
              (expand-file-name scope)))))

(defun org-glance-scope--detect (scope)
  (cond
   ((and (stringp scope) (file-exists-p scope))
    `(:type :file
            :name ,(expand-file-name scope)
            :handle ,scope))
   ((bufferp scope)
    `(:type :buffer
            :name ,(buffer-name scope)
            :handle ,scope))
   ((and (bufferp scope) (buffer-file-name scope) (file-exists-p (buffer-file-name scope)))
    `(:type :file-buffer
            :name ,(expand-file-name (buffer-file-name scope))
            :handle ,scope))))

(defun org-glance-scope-visit (scope)
  (case (org-glance-scope-type scope)
    (:file (find-file (org-glance-scope-handle scope)))
    (:file-buffer (switch-to-buffer (org-glance-scope-handle scope)))
    (:buffer (switch-to-buffer (org-glance-scope-handle scope)))))

(defun org-glance-scope-contents-insert (scope)
  (case (org-glance-scope-type scope)
    (:file (insert-file-contents (org-glance-scope-handle scope)))
    (:file-buffer (insert-file-contents (buffer-file-name (org-glance-scope-handle scope))))
    (:buffer (insert-buffer-substring-no-properties (org-glance-scope-handle scope)))))

(defun org-glance-scope-entries (scope)
  (loop for fob in scope
        append (save-window-excursion
                 (save-excursion
                   (org-glance-scope-visit fob)
                   (org-map-entries #'org-glance-entry-location-at-point)))))

;; (->> (org-agenda-files)
;;      org-glance-scope-create
;;      org-glance-scope-entries
;;      org-glance-entries-browse)

(defun org-glance-entries-browse (entries)
  (let* ((prompt "Glance: ")
         (separator org-glance-defaults--separator)
         (choice (org-completing-read prompt
                                      (loop for entry in entries
                                            collect (org-glance-entry-location-outline-format separator entry))))
         (entry (loop for entry in entries
                      when (string= (org-glance-entry-location-outline-format separator entry)
                                    choice)
                      do (return entry)))
         (marker (org-glance-entry-location-marker entry)))
    entry))

(cl-defun org-glance-scope-create (lfob)
  (if (listp lfob)
      (-some->> lfob
                (-keep #'(lambda (f) (->> f org-glance-scope-create car)))
                -flatten
                seq-uniq)
    (or (-some->> lfob
                  org-glance-scope--prepr
                  org-glance-scope--detect
                  (apply #'org-glance-scope--create)
                  list)
        (-some->> (current-buffer)
                  org-glance-scope-create
                  list))))
#+end_src
*** tests                                                                     :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/scope-constructor-returns-list-of-fobs ()
  "Scope constructor should generate list of files-or-buffers."
  (should (equal (org-glance-scope-create (current-buffer)) (org-glance-scope-create (list (current-buffer)))))
  (should (equal (org-glance-scope-create (current-buffer)) (org-glance-scope-create (list (list (current-buffer)))))))
#+end_src
*** entries
#+begin_src emacs-lisp
(cl-defstruct (org-glance-entry-location (:constructor org-glance-entry-location--create)
                                         (:copier nil))
  scope outline marker)

(cl-defun org-glance-entry-location-at-point ()
  (let ((scope (car (org-glance-scope-create (current-buffer)))))
    (org-glance-entry-location--create
     :scope scope
     :outline (cl-list* (org-glance-scope-name scope)
                        (org-get-outline-path t))
     :marker (point-marker))))

(defun org-glance-entry-location-outline-format (separator entry)
  (->> entry
       org-glance-entry-location-outline
       (s-join separator)))

(defun org-glance-entry-location-visit (entry)
  (->> entry
       org-glance-entry-location-marker
       org-goto-marker-or-bmk))

(defun org-glance-entry-location-act (entry &optional action)
  (org-glance-entry-location-visit entry)
  (if action
      (funcall action)
    (let* ((line (thing-at-point 'line t))
           (search (string-match org-any-link-re line))
           (link (substring line (match-beginning 0) (match-end 0)))
           (org-link-frame-setup (cl-acons 'file 'find-file org-link-frame-setup)))
      (org-open-link-from-string link))))
#+end_src
*** implant
#+begin_src emacs-lisp
(defun org-glance-scope--implant (scope)
  (with-temp-file org-glance-cache-file
    (org-mode)

    (when (file-exists-p org-glance-cache-file)
      (insert-file-contents org-glance-cache-file))

    (let* ((contents (org-glance-cache--get-scope-state-headlines scope))
           (state (car contents))
           (entries (cadr contents))
           (scope-name (org-glance-scope--get-name scope))
           (cached-scope (org-glance-cache--get-scope scope-name)))

      (when (and (or (not cached-scope)
                     (not (string= state (car cached-scope))))
                 (> (length entries) 0)
                 (not (string= org-glance-cache-file scope-name)))
        (org-glance-cache--remove-scope scope-name)
        (org-glance-cache--add-scope scope-name entries state)
        ;; TODO: possible optimization/add-scope can return scope
        (setq cached-scope (org-glance-cache--get-scope scope-name)))

      (when-let ((scope-point (cadr cached-scope)))
        (let ((outliner (apply-partially
                         'org-glance--get-entry-coordinates
                         :separator separator
                         :outline-ignore outline-ignore
                         :filters filters
                         :inplace inplace-p
                         :scope org-glance-cache-file)))
          (save-excursion
            (goto-char scope-point)
            (org-map-entries outliner nil 'tree)))))))
#+end_src
*** defaults
**** archives
#+begin_src emacs-lisp
(defun org-glance-scope--list-archives ()
  (let ((fn (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
    (directory-files-recursively default-directory (concat fn ".org_archive"))))
#+end_src
*** Tests [2/4]
**** DONE Return must contain no duplicates                                  :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/scopes-contain-no-duplicates ()
  "Scope should not contain duplicates."
  (let ((scopes
         (org-glance--with-temp-filebuffer
          (org-glance-scope-create
           `(;; buffer
             ,(current-buffer)
             ;; filename
             ,(buffer-file-name)
             ;; function symbol that returns buffer
             current-buffer
             ;; function that returns filename
             buffer-file-name)))))
    (should (= (length scopes) 1))))
#+end_src
**** DONE Proper handling lambda with nil return                             :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/scopes-can-handle-nil-lambdas ()
  "Ignore nil lambdas in scopes."
  (should (->> (condition-case nil
                   (org-glance-scope-create (list (lambda () nil)))
                 (error nil))
               null
               not)))
#+end_src
**** TODO Input must handle scopes of types: buffer, fun, filename
**** TODO Proper handle nil input
** filter
*** def
#+begin_src emacs-lisp
(defvar org-glance--default-filters
  '((links . (lambda () (org-match-line (format "^.*%s.*$" org-bracket-link-regexp))))
    (encrypted . (lambda () (seq-intersection (list "crypt") (org-get-tags-at))))))

(cl-defstruct (org-glance-filter (:constructor org-glance-filter--create)
                                 (:copier nil))
  handler)

(cl-defun org-glance-filter-create (&optional filter)
  "Factorize FILTER into list of predicates. Acceptable FILTER values:
- list of symbols (possible default filters) and lambdas (custom filters)
- string name of default filter
- symbolic name of default filter
- lambda function with no params called on entry"
  (cond ((null filter) (org-glance-filter-create #'(lambda () t)))
        ((functionp filter) (-some->> filter
                                      (org-glance-filter--create :handler)
                                      list))
        ((symbolp filter) (-some->> (alist-get filter org-glance--default-filters)
                                    (org-glance-filter--create :handler)
                                    list))
        ((stringp filter) (-some->> filter
                                    intern
                                    org-glance-filter-create))
        ((listp filter) (mapcar #'(lambda (f) (thread-first f org-glance-filter-create car)) filter))
        (t (error "Unable to recognize filter."))))

(defun org-glance-filter-apply (filter &optional entry)
  (cond ((org-glance-filter-p filter)
         (save-window-excursion
           (save-excursion
             (when (org-glance-entry-location-p entry)
               (org-glance-entry-location-visit entry))
             (condition-case nil
                 (-some->> filter org-glance-filter-handler funcall)
               (error nil)))))
        ((listp filter)
         (-all? #'org-glance-filter-apply filter))

        ;; (entries
        ;;  (loop for entry in entries
        ;;        collect (save-window-excursion
        ;;                  (-all? (lambda (f) (condition-case nil
        ;;                                    (save-excursion
        ;;                                      (org-glance-entry-location-visit entry)
        ;;                                      (funcall f entry))
        ;;                                  (error nil))) filter))))
        )

  ;; (if entries
  ;;     (loop for entry in entries
  ;;           collect (save-window-excursion
  ;;                     (-all? (lambda (f) (condition-case nil
  ;;                                       (save-excursion
  ;;                                         (org-glance-entry-location-visit entry)
  ;;                                         (funcall f entry))
  ;;                                     (error nil))) filter)))
  ;;   (-all? (lambda (f) (condition-case nil
  ;;                     (save-excursion
  ;;                       (-some->> f
  ;;                                 org-glance-filter-handler
  ;;                                 funcall))
  ;;                   (error nil))) filter))
  )

(let ((entries (->> "/tmp/1.org"
                    org-glance-scope-create
                    org-glance-scope-entries))
      (filters (org-glance-filter-create "links")))
  filters
  ;; (org-glance-filter-apply filters entries)
  )
#+end_src
** COMMENT Tests [4/4]
*** DONE Can visit empty cache file                                           :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/can-work-with-empty-cache-file ()
  "Should work with empty cache file."
  (should
   (org-glance-test
    :context '(:no-cache-file t)
    :input "Hello")))
#+end_src
*** DONE Can visit org-links                                                  :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/can-handle-org-links ()
  "Test that we can handle org-links."
  (should
   (org-glance-test
    :context '(:no-cache-file t)
    :input "elisp-link")))
#+end_src
*** DONE Can complete non-file buffers                                        :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/compl-non-file-buffer ()
  "Should work properly from non-file buffers."
  (should
   (org-glance-test
    :context '(:no-cache-file t
               :inplace t
               :scope (list buffer))
    :input "elisp-link")))
#+end_src
*** DONE Can call custom action on entry                                      :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/can-call-custom-action ()
  "Should call custom action if specified."
  (should
   (org-glance-test
    :context '(:action (lambda () 1)
               :expected 1
               :inplace t
               :scope (list buffer))
    :input "elisp-link")))
#+end_src
** COMMENT Tests [3/3]
*** DONE Filter produces proper predicates                                    :Test:
#+begin_src emacs-lisp
(defun org-glance-req/filter-produces-proper-predicates-p (input expected)
  "Can we split user filter into atomic predicates?"
  (equal (org-glance--filter-predicates input) expected))

(defun org-glance-test-explainer/filter-produces-proper-predicates (filter expected)
  (cond ((functionp filter) "Unable to resolve lambda filter")
        ((symbolp filter) "Unable to resolve symbolic filter")
        ((stringp filter) "Unable to resolve string filter")
        ((listp filter) (loop for elt in filter
                              when (functionp elt) return "Unable to resolve lambda from filter list"
                              when (symbolp elt)   return "Unable to resolve symbol from filter list"
                              when (stringp elt)   return "Unable to resolve string from filter list"))
        (t "Unrecognized filter must raise an error")))

(put 'org-glance-req/filter-produces-proper-predicates-p
     'ert-explainer
     'org-glance-test-explainer/filter-produces-proper-predicates)

(ert-deftest org-glance-test/filter-produces-proper-predicates-lambda ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           (lambda () t) '((lambda () t)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-symbol ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           'links (list (alist-get 'links org-glance--default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-string ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           "links" (list (alist-get 'links org-glance--default-filters)))))

(ert-deftest org-glance-test/filter-produces-proper-predicates-list ()
  (should (org-glance-req/filter-produces-proper-predicates-p
           (list 'links (lambda () t) "links")
           (list (alist-get 'links org-glance--default-filters)
                 (lambda () t)
                 (alist-get 'links org-glance--default-filters)))))
#+end_src
*** DONE Filter removes entries                                               :Test:

#+begin_src emacs-lisp
(ert-deftest org-glance-test/filter-removes-entries ()
  "Test filtering."
  (should
   (condition-case nil
        (org-glance-test
         :context (list :no-cache-file t
                        :inplace t
                        :filter (lambda () (org-match-line "^ example$")))
         :input "elisp-link")
     (error t))))
#+end_src

*** DONE Filter doesnt remove suitable entries                                :Test:

#+begin_src emacs-lisp
(ert-deftest org-glance-test/filter-doesnt-remove-suitable-entries ()
  (should
   (org-glance-test
    :context (list :no-cache-file t
                   :inplace t
                   :filter (lambda () (org-match-line "^.*elisp-link.*$")))
    :input "elisp-link")))
#+end_src

** TODO cache
*** add-scope
#+begin_src emacs-lisp
;; org-element-interpret-data

(defun org-glance-cache--add-scope (scope entries state)
  (cl-loop for (title level) in entries
           for i below (length entries)
           with prev-level
           initially (progn
                       (goto-char (point-max))
                       (org-insert-heading nil nil t)
                       (insert scope)
                       (org-set-property "CREATED" (current-time-string))
                       (org-set-property "STATE" state)
                       (org-insert-heading-respect-content)
                       (org-do-demote))
           do (progn
                (insert title)
                (when prev-level
                  (cond ((> prev-level level) (dotimes (ld (- prev-level level)) (org-do-promote)))
                        ((< prev-level level) (dotimes (ld (- level prev-level)) (org-do-demote))))))

           when (< (+ i 1) (length entries))
           do (progn
                (org-insert-heading-respect-content)
                (setq prev-level level))))
#+end_src
*** get-scope
#+begin_src emacs-lisp
(defun org-glance-cache--get-scope (scope-name)
  (car
   (org-element-map (org-element-parse-buffer 'headline) 'headline
     (lambda (hl)
       (let* (
              ;; maybe map properties?
              ;; (org-element-map hl 'node-property
              ;;   (lambda (np)
              ;;     (cons (org-element-property :key np)
              ;;           (org-element-property :value np))))

              (level (org-element-property :level hl))
              (title (org-element-property :title hl))
              (begin (org-element-property :begin hl))

              (end (org-element-property :end hl)))
         (when (and (= level 1) (string= title scope-name))
           (save-excursion
             (goto-char begin)
             (let* ((props (org-element--get-node-properties))
                    (state (plist-get props :STATE)))
               (org-set-property "USED" (current-time-string))
               (list state begin end)))))))))
#+end_src
*** get-scope-state-elements
#+begin_src emacs-lisp
(defun org-glance-cache--get-scope-state-headlines (scope)
  (with-temp-buffer
    (org-mode)
    (org-glance-cache--insert-contents scope)
    (list (buffer-hash)
          (org-element-parse-buffer 'headline))))
#+end_src
*** delete-scope
#+begin_src emacs-lisp
(defun org-glance-cache--remove-scope (scope-name)
  (when-let (scope (org-glance-cache--get-scope scope-name))
    (delete-region (cadr scope) (caddr scope))))
#+end_src
** TODO sort-entries                                                           :Experiment:
*** Tests
**** classification problem
classes:
- i.e. bookmarks or passwords
- items must be normally distributed
- hashtable of items?

independent variables (normalization needed):
- (sxhash (buffer-hash))
- (point)
- (sxhash (substring-no-properties (thing-at-point 'line)))
- (sxhash (buffer-file-name))
- (sxhash (save-window-excursion (org-clock-goto) (substring-no-properties (thing-at-point 'line))))
- org-clock tags, properties
- buffer major mode

connections:
-

#+begin_src emacs-lisp
;; (require 'eieio)

;; (cl-defmethod add-to-cache)
;; (cl-defmethod get-from-cache)
;; (cl-defmethod insert-contents ())

(oref (og-scope :source "/tmp/hello.txt") state)



(oref  state)

;; (defclass og-context (eieio-persistent)
;;   ((mode
;;     :type symbol
;;     :initarg :mode
;;     :initform (buffer-mode))

;;    (file
;;     :type string
;;     :initarg :file
;;     :initform "~/.context")

;;    (target
;;     :type string
;;     :initarg :target)

;;    (targets
;;     :type cl-hash-table
;;     :initform (make-hash-table :test 'equal)
;;     :allocation :class
;;     :documentation "Targets with features."))
;;   "Org-glance context.")

;; (cl-defmethod initialize-instance :after ((obj og-context) &rest _)
;;   (with-slots (mode target targets) obj
;;     (let* ((features (gethash target targets (make-hash-table :test 'equal)))
;;            (coeff (+ (gethash mode features 0) 1)))
;;       (puthash mode coeff features)
;;       (puthash target features targets))))

;; (require 'json)

;; ;; slots
;; (loop for slot in (eieio-class-slots og-context)
;;       collect (eieio-slot-descriptor-name slot))

;; ;; targets
;; (with-temp-file "~/.context"
;;   (insert (json-encode-hash-table (oref-default og-context targets))))

;; (json-read-file "~/.context")
#+end_src
** DONE provision
#+begin_src emacs-lisp
(provide 'org-glance)
;;; org-glance.el ends here
#+end_src
*** Tests [1/1]
**** DONE feature-provision                                                  :Test:
#+begin_src emacs-lisp
(ert-deftest org-glance-test/feature-provision ()
  (should (featurep 'org-glance)))
#+end_src
* Applications
** org-glance-snippets
** org-glance-passwords
** org-glance-bookmarks
** org-glance-fs
* Todo
** TODO Use org-current-tag-alist
** TODO cache properties
** TODO profiler-start/profiler-report analyze
** TODO Fix fast insertion error (org-glance-cache-file does not have time to create)
* Settings
# Local Variables:
# org-literate-test-buffer: "*org-glance-tests*"
# org-literate-test-selector: "^org-glance-test/"
# org-use-tag-inheritance: t
# org-source-preserve-indentation: t
# org-adapt-indentation: nil
# indent-tabs-mode: nil
# End:
